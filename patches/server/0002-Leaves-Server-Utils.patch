From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: violetc <58360096+s-yh-china@users.noreply.github.com>
Date: Tue, 13 Sep 2022 16:59:31 +0800
Subject: [PATCH] Leaves Server Utils


diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index c89f6986eda5a132a948732ea1b6923370685317..5a0655dabc032a29062dfdd9f9d3fc9e8d25f6b7 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -26,7 +26,7 @@ public abstract class AreaMap<E> {
 
     // we use linked for better iteration.
     // map of: coordinate to set of objects in coordinate
-    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f); // Leaves - not final
     protected final PooledLinkedHashSets<E> pooledHashSets;
 
     protected final ChangeCallback<E> addCallback;
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
index 46954db7ecd35ac4018fdf476df7c8020d7ce6c8..044c51ebb058fc36074fd178929e3279335f6c99 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
@@ -5,7 +5,7 @@ import net.minecraft.server.level.ServerPlayer;
 /**
  * @author Spottedleaf
  */
-public final class PlayerAreaMap extends AreaMap<ServerPlayer> {
+public class PlayerAreaMap extends AreaMap<ServerPlayer> { // Leaves - not final
 
     public PlayerAreaMap() {
         super();
diff --git a/src/main/java/top/leavesmc/leaves/LeavesLogger.java b/src/main/java/top/leavesmc/leaves/LeavesLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..890b91a95719f18a75bc2c2176ef5cb9f2bf4274
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/LeavesLogger.java
@@ -0,0 +1,16 @@
+package top.leavesmc.leaves;
+
+import org.bukkit.Bukkit;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class LeavesLogger extends Logger {
+    public static final LeavesLogger LOGGER = new LeavesLogger();
+
+    private LeavesLogger() {
+        super("Leaves", null);
+        setParent(Bukkit.getLogger());
+        setLevel(Level.ALL);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java b/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c5449426b69dc711ca935f57cd8180f56219879
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java
@@ -0,0 +1,52 @@
+package top.leavesmc.leaves.util;
+
+import com.google.common.collect.Queues;
+import top.leavesmc.leaves.LeavesLogger;
+
+import java.util.Queue;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.BooleanSupplier;
+import java.util.logging.Level;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class AsyncExecutor implements Runnable {
+
+    private Queue<Runnable> jobs = Queues.newConcurrentLinkedQueue();
+    private final Thread thread;
+    private final BooleanSupplier shouldRun;
+    private volatile boolean killswitch = false;
+
+    public AsyncExecutor(String threadName, BooleanSupplier shouldRun) {
+        this.thread = new Thread(this, threadName);
+        this.shouldRun = shouldRun;
+    }
+
+    public void start() {
+        thread.start();
+    }
+
+    public void kill() {
+        killswitch = true;
+    }
+
+    public void submit(Runnable runnable) {
+        jobs.offer(runnable);
+    }
+
+    @Override
+    public void run() {
+        while (!killswitch) {
+            if (shouldRun.getAsBoolean()) {
+                try {
+                    Runnable runnable;
+                    while ((runnable = jobs.poll()) != null) {
+                        runnable.run();
+                    }
+                } catch (Exception e) {
+                    LeavesLogger.LOGGER.log(Level.SEVERE, e,  () -> "Failed to execute async job for thread " + thread.getName());
+                }
+            }
+            LockSupport.parkNanos("executing tasks", 1000L);
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java b/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ccc1b3b29e9d62526b2d7c56ef06db77704bf80
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java
@@ -0,0 +1,32 @@
+package top.leavesmc.leaves.util;
+
+import com.destroystokyo.paper.util.misc.PlayerAreaMap;
+import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+import net.minecraft.server.level.ServerPlayer;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class AsyncPlayerAreaMap extends PlayerAreaMap {
+
+    public AsyncPlayerAreaMap() {
+        super();
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
+        super(pooledHashSets);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback) {
+        this(pooledHashSets, addCallback, removeCallback, null);
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback, final ChangeSourceCallback<ServerPlayer> changeSourceCallback) {
+        super(pooledHashSets, addCallback, removeCallback, changeSourceCallback);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java b/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..0dc58b78c84a825ec7025534cd0fc7be9c4610ad
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java
@@ -0,0 +1,21 @@
+package top.leavesmc.leaves.util;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Iterator;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class IterableWrapper<T> implements Iterable<T> {
+
+    private final Iterator<T> iterator;
+
+    public IterableWrapper(Iterator<T> iterator) {
+        this.iterator = iterator;
+    }
+
+    @NotNull
+    @Override
+    public Iterator<T> iterator() {
+        return iterator;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java b/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b684d8f576acbc5de8d06b0ff779c257198bc32d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java
@@ -0,0 +1,41 @@
+package top.leavesmc.leaves.util;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public class Long2ObjectOpenHashMapWrapper<V> extends Long2ObjectOpenHashMap<V> {
+
+    private final Map<Long, V> backingMap;
+
+    public Long2ObjectOpenHashMapWrapper(Map<Long, V> map) {
+        backingMap = map;
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        return backingMap.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return backingMap.get(key);
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backingMap.remove(key);
+    }
+
+    @Nullable
+    @Override
+    public V putIfAbsent(Long key, V value) {
+        return backingMap.putIfAbsent(key, value);
+    }
+
+    @Override
+    public int size() {
+        return backingMap.size();
+    }
+}
