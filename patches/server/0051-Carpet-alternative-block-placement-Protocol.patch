From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: violetc <58360096+s-yh-china@users.noreply.github.com>
Date: Thu, 8 Dec 2022 19:40:00 +0800
Subject: [PATCH] Carpet alternative block placement Protocol


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index f6f9ae994c06fea9e0382d69726e4bbc944784af..b2d5218bd97be400cd18185e9a5305df76635d6e 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1960,7 +1960,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
             Vec3 vec3d2 = vec3d.subtract(vec3d1);
             double d0 = 1.0000001D;
 
-            if (Math.abs(vec3d2.x()) < 1.0000001D && Math.abs(vec3d2.y()) < 1.0000001D && Math.abs(vec3d2.z()) < 1.0000001D) {
+            if (top.leavesmc.leaves.LeavesConfig.carpetAlternativeBlockPlacement || (Math.abs(vec3d2.x()) < 1.0000001D && Math.abs(vec3d2.y()) < 1.0000001D && Math.abs(vec3d2.z()) < 1.0000001D)) { // Leaves - carpetAlternativeBlockPlacement
                 Direction enumdirection = movingobjectpositionblock.getDirection();
 
                 this.player.resetLastActionTime();
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index 62d6c5b7590ff4faef5d8c7a8be03155b7338480..753d81a8daabfc424af323f9ebf52415b2fb618f 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -156,7 +156,7 @@ public class BlockItem extends Item {
 
     @Nullable
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.getBlock().getStateForPlacement(context);
+        BlockState iblockdata = this.getBlock().getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
 
         return iblockdata != null && this.canPlace(context, iblockdata) ? iblockdata : null;
     }
diff --git a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
index d48fca67718290dd22133e72715646b3e1de4099..e0ab3f5bb3bc1da1941d10821b38bf4c0d66d6b7 100644
--- a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
+++ b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
@@ -27,7 +27,7 @@ public class StandingAndWallBlockItem extends BlockItem {
     @Nullable
     @Override
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.wallBlock.getStateForPlacement(context);
+        BlockState iblockdata = this.wallBlock.getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
         BlockState iblockdata1 = null;
         Level world = context.getLevel();
         BlockPos blockposition = context.getClickedPos();
@@ -38,7 +38,7 @@ public class StandingAndWallBlockItem extends BlockItem {
             Direction enumdirection = aenumdirection[j];
 
             if (enumdirection != Direction.UP) {
-                BlockState iblockdata2 = enumdirection == Direction.DOWN ? this.getBlock().getStateForPlacement(context) : iblockdata;
+                BlockState iblockdata2 = enumdirection == Direction.DOWN ? this.getBlock().getRealStateForPlacement(context) : iblockdata; // Leaves - carpetAlternativeBlockPlacement
 
                 if (iblockdata2 != null && iblockdata2.canSurvive(world, blockposition)) {
                     iblockdata1 = iblockdata2;
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 2e65b44f10aeb44fd524a58e7eb815a566c1ad61..138e7c233f087da4c7f0c7adb58648b9da45ec1b 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -429,6 +429,19 @@ public class Block extends BlockBehaviour implements ItemLike {
 
     public void stepOn(Level world, BlockPos pos, BlockState state, Entity entity) {}
 
+    // Leaves start - carpetAlternativeBlockPlacement
+    @Nullable
+    public BlockState getRealStateForPlacement(BlockPlaceContext ctx) {
+        if (top.leavesmc.leaves.LeavesConfig.carpetAlternativeBlockPlacement) {
+            BlockState tryState = top.leavesmc.leaves.protocol.CarpetAlternativeBlockPlacement.alternativeBlockPlacement(this, ctx);
+            if (tryState != null) {
+                return tryState;
+            }
+        }
+        return getStateForPlacement(ctx);
+    }
+    // Leaves end - carpetAlternativeBlockPlacement
+
     @Nullable
     public BlockState getStateForPlacement(BlockPlaceContext ctx) {
         return this.defaultBlockState();
diff --git a/src/main/java/top/leavesmc/leaves/LeavesConfig.java b/src/main/java/top/leavesmc/leaves/LeavesConfig.java
index 88544d0972e0f1d4339b8a5da8085c0643b799d5..ae6fa6d4dbd350841ed1924477d02a2c974f5aed 100644
--- a/src/main/java/top/leavesmc/leaves/LeavesConfig.java
+++ b/src/main/java/top/leavesmc/leaves/LeavesConfig.java
@@ -422,6 +422,15 @@ public final class LeavesConfig {
         jadeProtocol = getBoolean("settings.protocol.jade-protocol", jadeProtocol);
     }
 
+    public static boolean carpetAlternativeBlockPlacement = false;
+    private static void carpetAlternativeBlockPlacement() {
+        carpetAlternativeBlockPlacement = getBoolean("settings.protocol.carpet-alternative-block-placement", carpetAlternativeBlockPlacement);
+        if (carpetAlternativeBlockPlacement) {
+            LeavesLogger.LOGGER.warning("If use carpet-alternative-block-placement, too far away form hit block check of UseItemOnPacket will be broken.");
+            LeavesLogger.LOGGER.warning("If you do not use it, you need to set it to false");
+        }
+    }
+
     public static final class WorldConfig {
 
         public final String worldName;
diff --git a/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
new file mode 100644
index 0000000000000000000000000000000000000000..848c380ed3d9755bab680b1e244a6024110bc383
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
@@ -0,0 +1,101 @@
+package top.leavesmc.leaves.protocol;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.ComparatorBlock;
+import net.minecraft.world.level.block.RepeaterBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.ComparatorMode;
+import net.minecraft.world.level.block.state.properties.DirectionProperty;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.phys.Vec3;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
+
+public class CarpetAlternativeBlockPlacement {
+
+    @Nullable
+    public static BlockState alternativeBlockPlacement(@NotNull Block block, @NotNull BlockPlaceContext context) {
+        Vec3 hitPos = context.getClickLocation();
+        BlockPos blockPos = context.getClickedPos();
+        double relativeHitX = hitPos.x - blockPos.getX();
+        BlockState state = block.getStateForPlacement(context);
+
+        if (relativeHitX < 2 || state == null) {
+            return null;
+        }
+
+        DirectionProperty directionProp = getFirstDirectionProperty(state);
+        int protocolValue = ((int) relativeHitX - 2) / 2;
+
+        if (directionProp != null) {
+            Direction origFacing = state.getValue(directionProp);
+            Direction facing = origFacing;
+            int facingIndex = protocolValue & 0xF;
+
+            if (facingIndex == 6) {
+                facing = facing.getOpposite();
+            } else if (facingIndex <= 5) {
+                facing = Direction.from3DDataValue(facingIndex);
+            }
+
+            if (!directionProp.getPossibleValues().contains(facing)) {
+                facing = context.getPlayer().getDirection().getOpposite();
+            }
+
+            if (facing != origFacing && directionProp.getPossibleValues().contains(facing)) {
+                if (state.getBlock() instanceof BedBlock) {
+                    BlockPos headPos = blockPos.relative(facing);
+
+                    if (!context.getLevel().getBlockState(headPos).canBeReplaced(context)) {
+                        return null;
+                    }
+                }
+
+                state = state.setValue(directionProp, facing);
+            }
+        } else if (state.hasProperty(BlockStateProperties.AXIS)) {
+            Direction.Axis axis = Direction.Axis.VALUES[protocolValue % 3];
+            state = state.setValue(BlockStateProperties.AXIS, axis);
+        }
+
+        protocolValue &= 0xFFFFFFF0;
+
+        if (protocolValue >= 16) {
+            if (block instanceof RepeaterBlock) {
+                Integer delay = (protocolValue / 16);
+
+                if (RepeaterBlock.DELAY.getPossibleValues().contains(delay)) {
+                    state = state.setValue(RepeaterBlock.DELAY, delay);
+                }
+            } else if (protocolValue == 16) {
+                if (block instanceof ComparatorBlock) {
+                    state = state.setValue(ComparatorBlock.MODE, ComparatorMode.SUBTRACT);
+                } else if (state.hasProperty(BlockStateProperties.HALF) && state.getValue(BlockStateProperties.HALF) == Half.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.HALF, Half.TOP);
+                } else if (state.hasProperty(BlockStateProperties.SLAB_TYPE) && state.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.SLAB_TYPE, SlabType.TOP);
+                }
+            }
+        }
+
+        return state;
+    }
+
+    @Nullable
+    public static DirectionProperty getFirstDirectionProperty(@NotNull BlockState state) {
+        for (Property<?> prop : state.getProperties()) {
+            if (prop instanceof DirectionProperty) {
+                return (DirectionProperty) prop;
+            }
+        }
+        return null;
+    }
+}
